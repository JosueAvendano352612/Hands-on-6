%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern int yylineno;
extern FILE *yyin;

int yylex(void);
void yyerror(const char *s);
extern char *yytext;

/* ===========================
TABLA DE SIMBOLOS Y SCOPES
=========================== */

#define MAX_SYMBOLS 256
#define MAX_SCOPE   64

typedef struct {
char name[64];
} Symbol;

/* Pila de scopes */
Symbol scopes[MAX_SCOPE][MAX_SYMBOLS];
int scopeCount[MAX_SCOPE];
int scopeTop = 0;

/* ===========================
MANEJO DE LA TABLA
=========================== */

/* Nuevo scope con una llave "{" */
void enterScope() {
scopeTop++;
scopeCount[scopeTop] = 0;
}

/* Salida de scope con "}" */
void exitScope() {
scopeTop--;
}

/* Buscar simbolo desde el scope actual hacia arriba */
int lookup(char *name) {
for (int s = scopeTop; s >= 0; s--) {
for (int i = 0; i < scopeCount[s]; i++) {
if (strcmp(scopes[s][i].name, name) == 0)
return 1;
}
}
return 0;
}

/* Insertar nueva variable */
void insertSymbol(char *name) {

```
for (int i = 0; i < scopeCount[scopeTop]; i++) {
    if (strcmp(scopes[scopeTop][i].name, name) == 0) {
        printf("Error semantico (linea %d): variable '%s' redeclarada\n",
                yylineno, name);
        return;
    }
}

strcpy(scopes[scopeTop][scopeCount[scopeTop]].name, name);
scopeCount[scopeTop]++;
```

}

%}

/* Tipos semanticos */
%union {
int ival;
char *sval;
}

/* Tokens */
%token <sval> ID
%token <ival> NUMBER
%token RESERVED
%token RETURN
%token OP_INCREMENT
%token UNKNOWN

/* Precedencias */
%left '+' '-'
%left '*' '/'
%right UMINUS

%type <ival> expression

%%

program:
external_list
;

external_list:
external_list external
| /* vacio */
;

external:
declaration
| function_def
;

declaration:
type_specifier ID ';'
{ insertSymbol($2); }
| type_specifier ID '=' expression ';'
{ insertSymbol($2); }
;

function_def:
type_specifier ID '(' params ')' block
{ insertSymbol($2); }
;

type_specifier:
RESERVED
;

params:
param_list
| /* vacio */
;

param_list:
param_list ',' param
| param
;

param:
type_specifier ID
{ insertSymbol($2); }
;

block:
'{' start_scope stmt_list '}' end_scope
;

start_scope:
{ enterScope(); }
;

end_scope:
{ exitScope(); }
;

stmt_list:
stmt_list statement
| /* vacio */
;

statement:
declaration
| assignment ';'
| expr_stmt
| return_stmt
| function_call ';'
| block
;

assignment:
ID '=' expression
{
if(!lookup($1)) {
printf("Error semantico (linea %d): variable '%s' no declarada\n",
yylineno, $1);
}
}
;

expr_stmt:
expression ';'
;

function_call:
ID '(' args ')'
{
if(!lookup($1)) {
printf("Error semantico (linea %d): funcion '%s' no declarada\n",
yylineno, $1);
}
}
;

args:
arg_list
| /* vacio */
;

arg_list:
arg_list ',' expression
| expression
;

return_stmt:
RETURN expression ';'
;

expression:
expression '+' expression
| expression '-' expression
| expression '*' expression
| expression '/' expression
| '-' expression %prec UMINUS
| NUMBER
| ID
{
if(!lookup($1)) {
printf("Error semantico (linea %d): variable '%s' no declarada\n",
yylineno, $1);
}
}
| function_call
| '(' expression ')'
;

%%

void yyerror(const char *s) {
fprintf(stderr, "Error sintactico (linea %d) cerca de "%s": %s\n",
yylineno, yytext, s);
}

int main(int argc, char **argv) {

```
const char *filename = "input.c";

if (argc > 1)
    filename = argv[1];

yyin = fopen(filename, "r");
if (!yyin) {
    fprintf(stderr, "ERROR: No se pudo abrir %s\n", filename);
    return 1;
}

printf("\n=== Iniciando analisis ===\n");
yyparse();
printf("=== Analisis completado ===\n\n");

return 0;
```

}
